<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <meta charset="utf-8" />
</head>
<script src="http://d3js.org/d3.v4.min.js" charset="utf-8"></script>
<script src="http://d3js.org/d3-queue.v3.min.js" type="text/javascript"></script>
<style>
    .tick line {
        shape-rendering: crispEdges;
        stroke: #000;
    }

    line.minor  {
        stroke: #777;
        stroke-dasharray: 2,2;
    }

    path.domain {
        fill: none;
        stroke: black;
    }

    /* Style for Custom Tooltip */
    div.tooltip {
        position: absolute;
        text-align: center;
        width: 60px;
        height: 28px;
        padding: 2px;
        font: 12px sans-serif;
        background: white;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
    }

</style>
<body onload="adjacency()">

<div id="vizcontainer">
    <svg style="width:2000px;height:2000px;border:1px lightgray solid;" />
</div>
<footer>
    <script>

        // Append Div for tooltip to SVG
        var div = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        var arr = []

        function adjacency(){
            d3.queue()
                .defer(d3.json, "edgelist_1.json")
                .await(function(error, file1) { createAdjacencyMatrix(file1); });

            function filterByID(obj)
            {
                //console.log(obj)

                if (obj.Purpose == "HO" && obj.Subscriber_Class == "Home Worker" && obj.Time_of_Day == "H04:H05")
                {
                    if(!arr.includes(obj.Origin_Zone))
                    {
                        arr.push(obj)
                    }
                    elseif (!arr.includes(obj.Destination_Zone))
                    {

                    }
                    return true;
                }
                else
                {
                    return false;
                }
            }

            function findAllNodes()
            {

            }

            function createAdjacencyMatrix(edgelist)
            {
                var factor = 10;
                var edgeHash = {};

                var edgeFiltered = edgelist.filter(filterByID)
                edgeFiltered.sort(function(a, b)
                {
                    return a.Origin_Zone-b.Origin_Zone
                })

                for (x in edgeFiltered)
                {
                    var zone = edgeFiltered[x].Origin_Zone + "-" + edgeFiltered[x].Destination_Zone;
                    edgeHash[zone] = edgeFiltered[x];
                }

                matrix = [];
                //create all possible edges
                for (a in edgeFiltered)
                {
                    for (b in edgeFiltered)
                    {
                        var grid = {zone: edgeFiltered[a].Origin_Zone + "-" + edgeFiltered[b].Destination_Zone, x: b, y: a, count: 0};
                        if (edgeHash[grid.zone]) {
                            grid.count = edgeHash[grid.zone].Count;
                        }
                        matrix.push(grid);
                    }
                }

                d3.select("svg")
                    .append("g")
                    .attr("transform", "translate(50,50)")
                    .attr("id", "adjacencyG")
                    .selectAll("rect")
                    .data(matrix)
                    .enter()
                    .append("rect")
                    .attr("width", factor)
                    .attr("height", factor)
                    .attr("x", function (d) {
                        return d.x * factor})
                    .attr("y", function (d) {
                        return d.y * factor})
                    .style("stroke", "black")
                    .style("stroke-width", "1px")
                    .style("fill", "red")
                    .style("fill-opacity", function (d) {
                        return d.count * .2
                    })
                    .on("mouseover", gridOver)


                var scaleSize = edgeFiltered.length * factor;
                var nameScale = d3.scalePoint().domain(edgeFiltered.map(function (el) {return el.Origin_Zone})).range([0,scaleSize],1);

                xAxis = d3.axisTop().scale(nameScale).tickSize(4);
                yAxis = d3.axisLeft(nameScale).tickSize(4);
                d3.select("#adjacencyG").append("g").call(xAxis).selectAll("text").style("text-anchor", "end").attr("transform", "translate(-10,-10) rotate(90)");
                d3.select("#adjacencyG").append("g").call(yAxis);

                function gridOver(d,i)
                {
                    d3.selectAll("rect").style("stroke-width", function (p) {return p.x == d.x || p.y == d.y ? "3px" : "1px"})
                    div.transition()
                        .duration(200)
                        .style("opacity", .9);
                    div.text(d.zone + " " + d.count)
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                }
            }
        }
    </script>
</footer>
</body>
</html>